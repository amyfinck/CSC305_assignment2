<!DOCTYPE html>
<html>

<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es

in vec4 vPosition;
in vec3 vNormal;
in vec4 vColor; // Note this is not actually getting used the compiler will optimize it out which will throw vertexAttribPointer errors on javascript side
in vec2 vTexCoord;

uniform mat4 modelViewMatrix;
uniform mat4 normalMatrix;
uniform mat4 projectionMatrix;
uniform vec4 lightPosition;

out vec3 fPos; // vertex position in eye coordinates
out vec3 fLpos; // light position in eye coordinates
out vec3 fN; // vertex normal in eye coordinates
out vec2 fTexCoord;

void
main()
{
    fPos = (modelViewMatrix * vPosition).xyz;
    fN = normalize( (normalMatrix*vec4(vNormal,0.0)).xyz);
    fLpos = lightPosition.xyz;

    fTexCoord = vTexCoord;
    gl_Position = projectionMatrix * modelViewMatrix * vPosition;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;

uniform vec4 ambientProduct, diffuseProduct, specularProduct;
uniform float shininess;

uniform sampler2D texture1;
uniform int useTextures;
uniform int drawHearts;

uniform vec2 resolution;
uniform float time;

in vec3 fPos;
in vec3 fLpos;
in vec3 fN;

in vec2 fTexCoord;
layout(location=0) out vec4 fragColor;

// EXACTLY the same as in the case of per vertex ADS
vec4 ads(vec3 pos, vec3 lpos, vec3 N)
{
    vec3 L = normalize(lpos - pos);
    vec3 V = normalize(-pos); // why?
    vec3 R = reflect(-L, N);
    // Compute terms in the illumination equation
    float lightDotNormal = max( dot(L, N), 0.0 );
    vec4 diffuse = vec4(0.0, 0.0, 0.0, 1.0);
    diffuse = diffuseProduct * lightDotNormal;
    float reflectedDotViewShiny = pow( max(dot(R, V), 0.0), shininess );
    vec4 specular = vec4(0.0, 0.0, 0.0, 1.0);
    specular = specularProduct * reflectedDotViewShiny;
    if( dot(L, N) < 0.0 )
    {
        specular = vec4(0.0, 0.0, 0.0, 1.0);
    }
    vec4 color = ambientProduct + diffuse + specular;
    color.a = 1.0;
    return color;
}

int heart(vec2 st)
{
    /*
    * I am basing the heart shape on this relation adapted from: https://www.desmos.com/calculator/ldlejwob3o
    *  I scaled it down to fit in the range of -1 to 1 in x and y:
    * ((2x)^2 + (2y)^2 - 1)^3 <= 4x^2 * 8y^3
    * I wanted to capture the heart shape in the range of -1.5 to 1.5 in x and y
    * st range from 0 to 1 therefore I needed to map 0 to -1.5 and 1 to 1.5
    */

    // maps s and t from 0 to 1 to -1.5 to 1.5
    float x = st.x * 3. - 1.5;
    float y = st.y * 3. - 1.5;

    // building up components of the lhs of the equation
    float xto2 = pow(2.*x, 2.);
    float yto2 = pow(2.*y, 2.);
    float xto2pyto2m1 = xto2 + yto2 - 1.;

    // calculate left hand side of the equation
    float lhs = pow(xto2pyto2m1, 3.);
    // calculate right hand side of the equation
    float rhs = pow(2.*x, 2.) * pow(2.*y, 3.);

    if(lhs <= rhs)
    {
        // If lhs <= rhs, then this value is in the heart shape I want to draw
        return 1;
    }
    else
    {
        // Otherwise, it is not in the heart shape
        return 0;
    }
}

void
main()
{
	if( useTextures == 0)
    {
        // If no texture set, use the color from the vertex shader
        fragColor = ads(fPos, fLpos, fN);
	}
	else
	{
		// if drawHearts is set, we want blend with a heart. Otherwise, just draw the texture
	    if(drawHearts == 1)
	    {
	        // divide by the canvas resolution passed into the shader to get s & t from 0 to 1
	        vec2 st = gl_FragCoord.xy/resolution.xy;

            // check if the current fragment is in the heart shape
            int is_in_heart = heart(st);

            if(is_in_heart == 1)
            {
                vec4 heartColor = vec4(1.0, 0.5, 0.5, 1);
                // if it is in the heart shape, blend the texture with the color from the vertex shader
            	fragColor = mix(texture( texture1, fTexCoord ), heartColor, 0.5);
            }
            else
            {
                // otherwise, just draw the texture
                fragColor = texture( texture1, fTexCoord );
            }
	    }
	    else
        {
            // otherwise, just draw the texture
            fragColor = texture( texture1, fTexCoord );
        }
	}
}
</script>

<script type="text/javascript" src="Common/webgl-utils.js"></script>
<script type="text/javascript" src="Common/initShaders.js"></script>

<script type="text/javascript" src="Common/MV.js"></script>
<script type="text/javascript" src="objects.js"></script>
<script type="text/javascript" src="main.js"></script>


<body>
<canvas id="gl-canvas" width="512" height="512">
Oops ... your browser doesn't support the HTML5 canvas element
</canvas>

<br/>
<br/>

<div id="animToggleButton">
    <input id="animToggleButton" type="button" value="Toggle Animation"
    />

</div><br/>

</div><br/>

<div id="textureToggleButton">
    <input id="textureToggleButtoni" type="button" value="Toggle Textures"
    />

</body>
</html>
